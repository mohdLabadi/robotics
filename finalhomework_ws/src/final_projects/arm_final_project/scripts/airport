#!/usr/bin/env python

from __future__ import print_function
import time
import rospy
import rospkg
import numpy as np
from planning.roadmap import Roadmap
from planning.problems import JointSpace
from arm_final_project.init_env import Env
from planning.samplers import ArmRandomSampler
from arm_controller.pid_controller import PIDController
from interbotix_xs_modules.arm import InterbotixManipulatorXS
from interbotix_xs_sdk.msg import *
from arm_state_estimation.tracker import CylinderTracker
from planning.search import ASTARPlanner
from planning.problems import JointSpace
from planning.samplers import ArmRandomSampler
from planning.roadmap import Roadmap
from arm_final_project.planning_context import Widowx250ArmPlanning

class Airport(object):
    def __init__(self):
        extents = np.array([[-3.14, 3.14], [-1.88, 1.99], [-2.15, 1.61], [-3.14, 3.14], [-1.75, 2.15], [-3.14, 3.14]])
        sampler = ArmRandomSampler(extents = extents)
        rospack = rospkg.RosPack()
        map_path = rospack.get_path('arm_final_project')
        problem = JointSpace()
        self.planning_context = Widowx250ArmPlanning()
        self.rm = Roadmap(problem, sampler, 20000, connection_radius=2.5, saveto=map_path+"/map/roadmap_joint_space_final_new_env.pkl")
        self.astar_planner = ASTARPlanner(self.rm)
        self.bot = InterbotixManipulatorXS("wx250s", "arm", "gripper")
        self.pid_controller = PIDController(self.bot)
        self.ct = CylinderTracker()
        self.AIRPORT_POS_DICT = self.planning_context.AIRPORT_POS_DICT

    def extract_plan(self, vpath):
        plan = []
        for i in vpath:
            plan.append(self.rm.vertices[i])
        return np.array(plan)

    def plan_and_execute(self, goal_name, detected_goal=None):
        '''
        Input:
            goal_name (string): 
                key value in AIRPORT_POS_DICT
        '''
        goal = self.AIRPORT_POS_DICT[goal_name]
        if goal_name.split('_')[0] == "pickup":
            goal[1] = detected_goal
        ### BEGIN SOLUTION
        # Build a clean numeric goal so that IK never sees None

        base_goal = self.AIRPORT_POS_DICT[goal_name]
        local_goal = []

        for i, val in enumerate(base_goal):
            if i == 1 and goal_name.split('_')[0] == "pickup":
                if detected_goal is not None:
                    local_goal.append(float(detected_goal))
                else:
                    local_goal.append(0.0 if val is None else float(val))
            else:
                local_goal.append(float(val))

        local_goal = np.array(local_goal, dtype=float)

        # use self.planning_context.compute_ik() to convert goal (which contains end effect location and orientation) to joint space
        # Note that we only need values for the first 6 joints (the last 3 joint values are for gripper fingers, and we will ignore them for now).
        goal_joint = self.planning_context.compute_ik(local_goal)[:6]
        
        # use controller.get_current_joints() to get the current joint values and cast it into numpy array
        start_joint = np.array(self.pid_controller.get_current_joints())

        # Insert current joint to roadmap as start position through self.rm.add_node, make use of the is_start flag
        # Use self.rm.add_node(), Assign output to a vairable called start_id 
        start_id = self.rm.add_node(start_joint, is_start=True)

        # Insert goal joint values you just computed to roadmap, make use of the is_start flag
        # Use self.rm.add_node(), Assign output to a vairable called goal_id 
        goal_id = self.rm.add_node(goal_joint, is_start=False)

        ### END SOLUTION

        vpath, _ = self.astar_planner.Plan(start_id, goal_id)
        plan = self.extract_plan(vpath)
        #### BEGIN SOLUTION, let the pid_controller excute the plan ####
        raw_traj = self.pid_controller.execute(plan)
        #### END SOLUTION ####
        self.bot.arm.core.robot_write_trajectory("group", "arm", "position", raw_traj)
        t = list(raw_traj[-1].keys())[0]
        time.sleep(t)
        if goal_name.split('_')[0] == "dropoff":
            rospy.set_param('object', 'none')  
            self.planning_context.publish_dummy_marker()
        if goal_name.split('_')[0] == "pickup":
            rospy.set_param('object', goal_name.split('_')[1])  
            airport.ct.pause_pf()
        return 

if __name__ == "__main__":
    try:
        print("")
        print("----------------------------------------------------------")
        print("Welcome to Corneller Airport, Time: 5/07/2051")
        print("----------------------------------------------------------")
        print("Press Ctrl-D to exit at any time")
        print("")
        print("Initialize Security Robot... ...")
        airport = Airport()
        airport.ct.pause_pf()
        
        env = Env(0.1, shape="tray")
        env.publish_obj()

        ###### BEGIN SOLUTION, PICKUP and DROPOFF TRAY #######
        airport.plan_and_execute("pickup_tray")
        airport.plan_and_execute("dropoff_tray")
        ###### END SOLUTION #######
  
        airport.planning_context.publish_tray_marker()

        airport.ct.resume_pf()
        env = Env(-0.04, shape="can")
        env.publish_obj()

        time.sleep(1)
        ##### BEGIN SOLUTION, get y value of the position of the can from the particle filter####
        can_val = airport.planning_context.package_location_y
        if isinstance(can_val, np.ndarray):
            if can_val.size == 0:
                can_position = 0.0
            elif can_val.size == 1:
                can_position = float(can_val.ravel()[0])
            else:
                # if it's something like [x, y, z], take y (index 1)
                can_position = float(can_val.ravel()[1])
        else:
            can_position = float(can_val)
        ##### END SOLUTION #####

        if can_position + 0.04 < 0.4:
            ###### BEGIN SOLUTION, PICKUP CAN #######
            airport.plan_and_execute("pickup_can", detected_goal=can_position)
            airport.plan_and_execute("dropoff_can")
            ###### END SOLUTION #######
        else:
            print("can localization failed, particle filter inaccurate.")
            exit(1)

  
        time.sleep(1)
        airport.ct.resume_pf()
        env = Env(-0.086, shape="wallet")
        env.publish_obj()

        time.sleep(1)
        ##### BEGIN SOLUTION, get y value of the position of the wallet from the particle filter####
        #### Hint: the y value is stored in  airport.planning_context.package_location_y
        wallet_val = airport.planning_context.package_location_y
        if isinstance(wallet_val, np.ndarray):
            if wallet_val.size == 0:
                wallet_position = 0.0
            elif wallet_val.size == 1:
                wallet_position = float(wallet_val.ravel()[0])
            else:
                # again, if [x, y, z], take y
                wallet_position = float(wallet_val.ravel()[1])
        else:
            wallet_position = float(wallet_val)
        ###### END SOLUTION #######

        if wallet_position + 0.086 < 0.4:
            ###### BEGIN SOLUTION, PICKUP WALLET #######
            airport.plan_and_execute("pickup_wallet", detected_goal=wallet_position)
            airport.plan_and_execute("dropoff_wallet")
            ###### END SOLUTION #######
        else:
            print("wallet localization failed, particle filter inaccurate.")
            exit(1)

    except rospy.ROSInterruptException:
        exit(1)
    except KeyboardInterrupt:
        exit(1)
